metadata_updator.py

from db_manager import DBManager
from datetime import date

class MetadataUpdater:
    def __init__(self, metadata_data, db_manager, table_name):
        self.metadata_data = metadata_data
        self.db_manager = db_manager
        self.table_name = table_name

    def update_metadata(self):
        if not self.metadata_data:
            print(f"No metadata to update for table {self.table_name}")
            return
            
        self.db_manager.ensure_table(self.table_name, self.metadata_data[0])
        
        # Get the maximum ID from the database to continue the sequence
        existing_metadata = self.db_manager.load_metadata(self.table_name)
        max_existing_id = max((row['id'] for row in existing_metadata), default=0)
        
        # Filter new metadata to only include today's date
        today = date.today().strftime("%Y-%m-%d")
        new_metadata_today = [row for row in self.metadata_data if row.get('present_on') == today]
        
        if not new_metadata_today:
            print(f"No new metadata for today ({today}) in table {self.table_name}")
            return
        
        # Assign unique IDs starting from max_existing_id + 1
        for i, row in enumerate(new_metadata_today, start=1):
            row['id'] = max_existing_id + i
        
        # Remove duplicates based on SafeName and present_on
        seen_safes_today = set()
        unique_metadata_today = []
        
        for row in new_metadata_today:
            safe_key = (row.get('SafeName', ''), row.get('present_on', ''))
            if safe_key not in seen_safes_today:
                seen_safes_today.add(safe_key)
                unique_metadata_today.append(row)
        
        # Check if we already have entries for today's safes
        existing_today = [row for row in existing_metadata if row.get('present_on') == today]
        existing_safes_today = set((row.get('SafeName', ''), row.get('present_on', '')) for row in existing_today)
        
        # Only insert safes that don't already exist for today
        final_metadata = []
        for row in unique_metadata_today:
            safe_key = (row.get('SafeName', ''), row.get('present_on', ''))
            if safe_key not in existing_safes_today:
                final_metadata.append(row)
        
        if final_metadata:
            self.db_manager.insert_rows(self.table_name, final_metadata)
            print(f"Inserted {len(final_metadata)} new metadata rows for {today} into {self.table_name}")
        else:
            print(f"No new unique metadata to insert for {today} in table {self.table_name}")


xml_parser.py

import os
import xml.etree.ElementTree as ET
import json
from collections import OrderedDict
from datetime import date

class XmlParser:
    def __init__(self, xml_file, collection_config):
        self.xml_file = xml_file
        self.collection_config = collection_config

    def parse_xml_file(self):
        try:
            tree = ET.parse(self.xml_file)
            root = tree.getroot()
            namespace = root.tag.split('}')[0].strip('{')
            ns_prefix = f'{{{namespace}}}' if namespace else ''
            collection_element = root.find(f'.//{ns_prefix}{self.collection_config["collections"][0]}')
            if collection_element is None:
                print(f"Collection not found: {self.collection_config['collections'][0]} in {self.xml_file}")
                return None
            data = []
            elements = collection_element.findall(f'{ns_prefix}*')
            attribute_name = self.collection_config["attribute_names"][0]
            attribute_values = self.collection_config["attribute_values"]
            for element in elements:
                if attribute_name in element.attrib and element.attrib.get(attribute_name) in attribute_values:
                    row = OrderedDict()
                    row['id'] = len(data) + 1
                    for attr in element.attrib:
                        row[attr] = element.attrib.get(attr, '')
                    row['ImportDate'] = date.today().strftime("%Y-%m-%d")
                    row['Assignee'] = ''
                    row['Action'] = ''
                    row['Remediation'] = ''
                    row['Comments'] = ''
                    row['Status'] = ""
                    data.append(row)
            return data
        except Exception as e:
            print(f"Error parsing {self.xml_file}: {e}")
            return None

    def parse_xml_file_metadata(self, output_dir, metadata_table_name, table_name):
        try:
            tree = ET.parse(self.xml_file)
            root = tree.getroot()
            namespace = root.tag.split('}')[0].strip('{')
            ns_prefix = f'{{{namespace}}}' if namespace else ''
            collection_element = root.find(f'.//{ns_prefix}{self.collection_config["collections"][0]}')
            if collection_element is None:
                print(f"Collection not found: {self.collection_config['collections'][0]} in {self.xml_file}")
                return None
            
            metadata_rows = []
            today = date.today().strftime("%Y-%m-%d")
            
            # Get elements from XML
            elements = collection_element.findall(f'{ns_prefix}*')
            attribute_name = self.collection_config["attribute_names"][0]
            attribute_values = self.collection_config["attribute_values"]
            
            # Track unique safes for today to avoid duplicates
            seen_safes = set()
            temp_safe_id = 1
            
            for element in elements:
                if attribute_name in element.attrib and element.attrib.get(attribute_name) in attribute_values:
                    # Extract SafeName from element attributes
                    safe_name = next((element.attrib.get(k, '') for k in element.attrib if k.lower() == 'safename'), '')
                    
                    # Skip if we've already seen this safe today
                    if safe_name in seen_safes:
                        continue
                    seen_safes.add(safe_name)
                    
                    metadata_row = OrderedDict()
                    # Don't assign ID here - let MetadataUpdater handle it
                    metadata_row['id'] = temp_safe_id  # Temporary ID, will be reassigned
                    metadata_row['SafeId'] = temp_safe_id  # Simple incremental SafeId for new safes
                    metadata_row['SafeName'] = safe_name
                    metadata_row['present_on'] = today
                    metadata_rows.append(metadata_row)
                    temp_safe_id += 1
            
            return metadata_rows
            
        except Exception as e:
            print(f"Error parsing metadata from {self.xml_file}: {e}")
            return None


