import os
import re
from datetime import datetime

def load_config(config_file):
    config = {}
    with open(config_file, 'r', encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            if line and '=' in line:
                key, value = line.split('=', 1)
                config[key.strip()] = value.strip()
    return config

def get_creation_time(path):
    try:
        return os.path.getctime(path)
    except Exception:
        return None

def compile_patterns(pattern_str):
    return [re.compile(p.strip()) for p in pattern_str.split(',') if p.strip()]

def read_input_paths(input_file):
    if not input_file or not os.path.exists(input_file):
        return []
    with open(input_file, 'r', encoding='utf-8') as f:
        return [line.strip() for line in f if os.path.exists(line.strip())]

def scan_and_generate(config):
    input_file = config.get('INPUT_FILE')
    output_dir = config.get('OUTPUT_DIR')
    expected_time_raw = config.get('EXPECTED_ARRIVAL_TIME', '')
    pattern_str = config.get('FILENAME_PATTERNS', '')
    compiled_patterns = compile_patterns(pattern_str)

    if not output_dir or not os.path.isdir(output_dir):
        current_user = os.getlogin()
        output_dir = os.path.join("C:\\Users", current_user, "Downloads")

    output_txt = os.path.join(output_dir, "ppredefinedfiles.txt")
    os.makedirs(output_dir, exist_ok=True)

    # Load previous data by filename as key
    previous_data = {}
    if os.path.exists(output_txt):
        with open(output_txt, 'r', encoding='utf-8') as f:
            for line in f:
                parts = line.strip().split('\t')
                if len(parts) >= 4:
                    filename = parts[0]
                    previous_data[filename] = parts

    # Scan current filesystem
    current_data = {}
    directories = read_input_paths(input_file)
    for base_dir in directories:
        for dirpath, _, filenames in os.walk(base_dir):
            if 'summaries' in dirpath.lower():
                continue
            for filename in filenames:
                if any(p.match(filename) for p in compiled_patterns):
                    full_path = os.path.join(dirpath, filename)
                    ctime = get_creation_time(full_path)
                    if ctime:
                        actual_time = datetime.fromtimestamp(ctime).strftime('%Y-%m-%d %H:%M:%S')
                        expected_time = f"{datetime.now().strftime('%Y-%m-%d')} {expected_time_raw}"
                        current_data[filename] = [filename, actual_time, full_path, expected_time]

    # Merge previous + current
    all_filenames = set(previous_data) | set(current_data)
    final_entries = []

    for fname in sorted(all_filenames):
        if fname in current_data:
            final_entries.append('\t'.join(current_data[fname]))
        else:
            prev = previous_data.get(fname, [fname, '', '', ''])
            prev[1] = 'File Not Found'
            prev[2] = 'File Not Found'
            prev[3] = f"{datetime.now().strftime('%Y-%m-%d')} {expected_time_raw}"
            final_entries.append('\t'.join(prev))

    with open(output_txt, 'w', encoding='utf-8') as f:
        for entry in final_entries:
            f.write(entry + '\n')

    print(f"âœ… Updated ppredefinedfiles.txt saved to: {output_txt}")
